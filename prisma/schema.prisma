generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Individual products (the actual items that exist)
model IndividualProduct {
  id                    String   @id
  name                  String
  swedishname           String
  description           String
  swedishdescription    String
  category              String   // "Cosmetic", "Food supplement", "Tea", "Supplement"
  unitType              String   // "masks", "tubes", "servings", "packs", "vials", "pods", "pairs"
  swedishUnitType       String   // "masker", "tubar", "portioner", "paket", "flaskor", "kapslar", "par"
  image                 String?
  storage               String
  coaLink               String?
  productType           String   @default("subinventoryitem") // "productlisting" or "subinventoryitem"
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  // Relations
  bundleItems           BundleItem[]
  shippingDestinations  ShippingDestination[]
}

// Orderable product bundles (what customers actually purchase)
model OrderableProductBundle {
  id                    String   @id
  name                  String
  swedishname           String
  description           String
  swedishdescription    String
  purity                String
  price                 Float    // Total price in SEK
  image                 String
  category              String
  correlatesto          String   // What Swedish compound this correlates to
  imagedescription      String
  tier                  Int      // 1, 2, 3, or 4
  productType           String   @default("productlisting") // "productlisting" for top-tier orderable groups
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  // Relations
  bundleItems           BundleItem[]
  cartItems             CartItem[]
  shippingDestinations  ShippingDestination[]
}

// Junction table for bundle contents
model BundleItem {
  id                    String   @id @default(uuid())
  quantity              Int
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  // Foreign keys
  bundleId              String
  bundle                OrderableProductBundle @relation(fields: [bundleId], references: [id], onDelete: Cascade)
  
  individualProductId   String
  individualProduct     IndividualProduct @relation(fields: [individualProductId], references: [id], onDelete: Cascade)
  
  @@unique([bundleId, individualProductId])
}

// Shipping destinations
model ShippingDestination {
  id                    String   @id @default(uuid())
  name                  String
  description           String
  productSpecific       Boolean  @default(false)
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  // Relations (can be associated with either bundles or individual products)
  bundleId              String?
  bundle                OrderableProductBundle? @relation(fields: [bundleId], references: [id], onDelete: Cascade)
  
  individualProductId   String?
  individualProduct     IndividualProduct? @relation(fields: [individualProductId], references: [id], onDelete: Cascade)
}

// Swedish products (base compounds) - kept for correlation
model SwedishProduct {
  id        String   @id
  name      String
  size      String
  price     Float    // in SEK
  compound  String   // base compound name
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Legacy Product model (keeping for backward compatibility)
model Product {
  id        String   @id @default(uuid())
  name      String
  description String
  purity    String
  price     Float
  image     String
  cas       String
  size      String
  storage   String
  createdAt DateTime @default(now())
  cartItems CartItem[]
}

model CartItem {
  id        String   @id @default(uuid())
  quantity  Int
  createdAt DateTime @default(now())
  
  // Relations (can be either legacy product or new bundle)
  product   Product?  @relation(fields: [productId], references: [id])
  productId String?
  
  bundle    OrderableProductBundle? @relation(fields: [bundleId], references: [id])
  bundleId  String?
}
